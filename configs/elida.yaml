# ELIDA Configuration
# Edge Layer for Intelligent Defense of Agents

# Address to listen on for proxied traffic
listen: ":8080"

# Single Backend Mode (backward compatible) - commented out when using multi-backend
# backend: "https://api.anthropic.com"

# Multi-Backend Mode
backends:
  anthropic:
    url: "https://api.anthropic.com"
    type: anthropic
    models: ["claude-*"]
    default: true     # Fallback backend

  mistral:
    url: "https://api.mistral.ai"
    type: mistral
    models: ["mistral-*", "codestral-*"]

# Routing method priority
routing:
  methods:
    - header        # X-Backend header (highest priority)
    - model         # Model name pattern matching from request body
    - path          # Path prefix (/anthropic/*, /mistral/*, etc.)
    - default       # Fallback to default backend

  # LLM05 - Supply Chain Security: Model access control
  # Reject requests if model doesn't match any backend pattern (no default fallback)
  strict_model_matching: false

  # Block specific models entirely (glob patterns)
  # blocked_models:
  #   - "gpt-4-turbo-*"      # Block all GPT-4 Turbo variants
  #   - "claude-3-opus-*"    # Block Opus (cost control)
  #   - "*-preview"          # Block all preview models

# TLS/HTTPS configuration
tls:
  # Enable HTTPS for the proxy server
  enabled: false
  # Path to TLS certificate file (PEM format)
  cert_file: ""
  # Path to TLS private key file (PEM format)
  key_file: ""
  # Auto-generate self-signed certificate (development only)
  auto_cert: false

# Session configuration
session:
  # How long before an idle session times out
  timeout: 5m
  # Header to use for session ID
  header: "X-Session-ID"
  # Generate a session ID if not provided
  generate_if_missing: true

  # Kill block configuration - how long killed sessions stay blocked
  kill_block:
    # Mode options:
    #   "duration"          - Block for a specific duration after kill
    #   "until_hour_change" - Block until the hour changes (session ID regenerates)
    #   "permanent"         - Block permanently until server restart
    mode: "duration"
    # Duration to block (only used if mode is "duration")
    duration: 30m

# Control API configuration
control:
  # Address for the control API
  listen: ":9090"
  # Enable the control API
  enabled: true

# Logging configuration
logging:
  # Log format: json or text
  format: json
  # Log level: debug, info, warn, error
  level: info

# Telemetry configuration (OpenTelemetry)
telemetry:
  # Enable telemetry
  enabled: false
  # Exporter type: otlp, stdout, or none
  exporter: none
  # OTLP endpoint (when exporter is otlp)
  endpoint: "localhost:4317"
  # Service name for traces
  service_name: "elida"
  # Use insecure connection (for local development)
  insecure: true

# Storage configuration (for dashboard history)
storage:
  # Enable SQLite storage for session history
  enabled: false
  # Path to SQLite database file
  path: "data/elida.db"
  # How many days to retain session history
  retention_days: 30
  # Capture mode: "all" (CDR-style, capture all session content) or "flagged_only"
  capture_mode: "all"

# Policy configuration (for flagging suspicious sessions)
# Based on OWASP LLM Top 10, NIST AI RMF, and OWASP API Security
#
# ELIDA uses a WAF-style policy model:
# - Presets provide comprehensive default rules (minimal, standard, strict)
# - Custom rules are appended to the preset rules
# - For full rule documentation, see: docs/POLICY_RULES_REFERENCE.md
policy:
  # Enable policy engine
  enabled: false

  # Mode: "enforce" (default) or "audit" (dry-run, log but don't block)
  mode: enforce

  # Capture request/response content for flagged sessions
  capture_flagged: true

  # Max bytes to capture per request (default 10KB)
  max_capture_size: 10000

  # Streaming response scanning configuration
  # Controls how response rules are evaluated for streaming (SSE/NDJSON) responses
  streaming:
    # Mode options:
    #   "chunked"  - Low latency: scan chunks as they arrive, terminate on detection
    #                Uses overlap buffer to catch patterns spanning chunk boundaries
    #                Client receives partial response before violation is detected
    #   "buffered" - Full buffer: accumulate entire response before sending
    #                Higher latency but guaranteed to catch all patterns
    #                Client sees nothing until full response is scanned
    mode: "chunked"

    # Overlap buffer size for chunked mode (bytes)
    # Retains this many bytes between chunks to catch cross-boundary patterns
    # Larger = better pattern detection, more memory
    # Default: 1024 (1KB - catches most injection patterns)
    overlap_size: 1024

    # Max buffer size for buffered mode (bytes)
    # If response exceeds this, sends unbuffered with warning
    # Default: 10485760 (10MB)
    max_buffer_size: 10485760

    # Buffer timeout for buffered mode (seconds)
    # Max time to wait for full response before giving up
    # Default: 60
    buffer_timeout: 60

  # Policy preset - provides default rules based on security frameworks
  # Options:
  #   minimal  - Rate limiting and critical blocks only (8 rules)
  #   standard - Balanced security with common patterns (38 rules) [recommended]
  #   strict   - Maximum security, lower thresholds (46 rules)
  #
  # See docs/POLICY_RULES_REFERENCE.md for complete rule documentation
  preset: standard

  # Custom rules - appended to preset rules
  # Use these to add organization-specific rules or override defaults
  #
  # Rule fields:
  #   name        - Unique identifier
  #   type        - "content_match", "request_count", "requests_per_minute",
  #                 "duration", "bytes_in", "bytes_out", "bytes_total"
  #   target      - "request", "response", "both" (default: both)
  #   patterns    - Regex patterns (for content_match type)
  #   threshold   - Numeric limit (for metric types)
  #   severity    - "info", "warning", "critical"
  #   action      - "flag", "block", "terminate"
  #   description - Human-readable description
  #
  # Streaming note for response rules:
  #   - "flag" action: Response streams normally, async scan after delivery (no latency)
  #   - "block/terminate" action: Response buffered before delivery (adds latency)
  #
  # Example custom rules:
  rules: []
    # Block internal project codenames in responses
    # - name: "internal_codenames"
    #   type: "content_match"
    #   target: "response"
    #   patterns:
    #     - "\\b(PROJECT_ALPHA|SKUNKWORKS|INTERNAL_ONLY)\\b"
    #   severity: "warning"
    #   action: "flag"
    #   description: "Response contains internal codenames"
    #
    # Block requests mentioning competitor products
    # - name: "competitor_mention"
    #   type: "content_match"
    #   target: "request"
    #   patterns:
    #     - "(compare|better than|vs|versus)\\s+(CompetitorA|CompetitorB)"
    #   severity: "info"
    #   action: "flag"
    #   description: "Request mentions competitor products"
    #
    # Lower rate limit for specific use case
    # - name: "custom_rate_limit"
    #   type: "requests_per_minute"
    #   threshold: 20
    #   severity: "warning"
    #   action: "block"
    #   description: "Custom rate limit for controlled environment"
